// ROS message includes
#include "ros/ros.h"
#include <squirrel_kclhand_msgs/Joints.h>
#include <include/KCLTCPDataClient.h>
/* protected region user include files on begin */
/* protected region user include files end */

class kclhand_config
{
public:
    std::string model;
    double Simulated_Joint_Pos_Gain;
    double Simulated_Joint_Inertia;
    double Simulation_Sampling_Time;
    double Simulated_Joint_Damping;
    std::string Hand_IP_Address;
    int Hand_Port;
};

class kclhand_data
{
// autogenerated: don't touch this class
public:
    //input data
    //output data
    squirrel_kclhand_msgs::Joints out_joint_states_out;
    bool out_joint_states_out_active;
};

class kclhand_impl
{
    /* protected region user member variables on begin */
    /* protected region user member variables end */

    std::vector<squirrel_kclhand_msgs::Joint> joint_vector; // Joint data vector
    KCLTCPDataClient *commChannel;


public:
    kclhand_impl() 
    {
        /* protected region user constructor on begin */
    	joint_vector.clear();

    	      const std::string joint_name_arr[] = {"met1", "met5", "th-mcp", "th-pip",
    	          "if-pip", "if-dip", "lf-pip", "lf-dip"};
    	      const int num_of_joints = 8;

    	      // Populate joint data vector
    	      for (int i = 0; i < num_of_joints; ++i)
    	      {
    	        // New joint data object
    	        squirrel_kclhand_msgs::Joint joint_data;

    	        // Set joint name
    	        std::stringstream ss;
    	        ss << joint_name_arr[i];
    	        joint_data.joint_name = ss.str();

    	        // Initialise all other parameters
    	        joint_data.joint_angle = 0.0;
    	        joint_data.joint_angle_setpoint_next = 0.0;
    	        joint_data.joint_angle_setpoint_tracked = 0.0;
    	        joint_data.joint_effort = 0.0;
    	        joint_data.joint_effort_control_enabled = false;
    	        joint_data.joint_effort_setpoint_next = 0.0;
    	        joint_data.joint_effort_setpoint_tracked = 0.0;
    	        joint_data.joint_status = "Initialised";
    	        joint_data.joint_velocity = 0.0;
    	        joint_data.motor_current = 0.0;

    	        // Add data to vector
    	        joint_vector.push_back(joint_data);
    	      }

    	      ROS_INFO("Joint structure initialised.");


    	      std::string hand_address;
    	      int hand_port;

    	      ros::param::get("~Hand_IP_Address", hand_address);
    	      ros::param::get("~Hand_Port", hand_port);

    	      commChannel = new KCLTCPDataClient(hand_address.c_str(), hand_port);
    	      commChannel->connectToHand();

        /* protected region user constructor end */
    }

    void configure(kclhand_config config) 
    {
        /* protected region user configure on begin */
        /* protected region user configure end */
    }

    void update(kclhand_data &data, kclhand_config config)
    {
        /* protected region user update on begin */
    	 ideal();

    	      commChannel->sendData();

    	      // Get length of joint state vector
    	      data.out_joint_states_out.joint_list_length = joint_vector.size();
    	      // Add joint state vector to message
    	      data.out_joint_states_out.joint_list = joint_vector;
        /* protected region user update end */
    }


    void callback_set_joint_controller_target_(const squirrel_kclhand_msgs::SetJointTargetGoalConstPtr &goal, actionlib::SimpleActionServer<squirrel_kclhand_msgs::SetJointTargetAction> *as_)
    {
        /* protected region user implementation of action callback for set_joint_controller_target on begin */
         //
         //

         // Create result object
         squirrel_kclhand_msgs::SetJointTargetActionFeedback::_feedback_type feedback_;
         squirrel_kclhand_msgs::SetJointTargetActionResult::_result_type result_;

         // Identify joint entry in joint vector
         int jointIndex = 0; // Start index at first entry of joint vector.
         bool jointFound = false;  // Assume joint name is not matched.
         for (std::vector<squirrel_kclhand_msgs::Joint>::iterator it = this->joint_vector.begin(); it != this->joint_vector.end(); ++it)
         {
           if (std::strcmp(goal->joint_name.data(), it->joint_name.data()) == 0)
           {
             // Joint name was found in joint vector. Set index and flags appropriately.
             jointFound = true;
             break;
           }
           else
             ++jointIndex; // Joint name is yet to be matched. Proceed with next iteration.
         }

         // Check to see if joint was found and proceed
         if (jointFound)
         {
           bool done = false;

           this->joint_vector[jointIndex].joint_angle_setpoint_next = goal->new_setpoint;

           while(!done)
           {
             // If new target is immediate, set both current and next setpoints to target.
             if(goal->track_now)
             {
               this->joint_vector[jointIndex].joint_angle_setpoint_tracked = goal->new_setpoint;
               done = true;
             }

             // Iterate until joint angle is within threshold.
             if ( std::abs(this->joint_vector[jointIndex].joint_angle - this->joint_vector[jointIndex].joint_angle_setpoint_tracked) <= 1.0)
               done = true;

             // Update feedback object with the status of the task execution.
             feedback_.joint_angle = this->joint_vector[jointIndex].joint_angle;
             feedback_.joint_effort = this->joint_vector[jointIndex].joint_effort;
             feedback_.joint_status = "Moving";

             // Send feedback to client.
             as_->publishFeedback(feedback_);
           }

           // We are done tracking. Report success result to client.
           result_.joint_angle = this->joint_vector[jointIndex].joint_angle;
           result_.joint_effort = this->joint_vector[jointIndex].joint_effort;
           result_.joint_status = "OK";
           as_->setSucceeded(result_);
         }
         else
         {
           // Joint name was not matched to a joint vector entry. Update result object appropriately.
           result_.joint_status = "Error! Joint not found";
           result_.joint_angle = 0.0;
           result_.joint_effort = 0.0;

           // Send result to client.
           as_->setAborted(result_);
         }

         //
         //
         /* protected region user implementation of action callback for set_joint_controller_target end */
    }
    void callback_track_new_setpoints_(const squirrel_kclhand_msgs::TrackNewSetpointsGoalConstPtr &goal, actionlib::SimpleActionServer<squirrel_kclhand_msgs::TrackNewSetpointsAction> *as_)
    {
        /* protected region user implementation of action callback for track_new_setpoints on begin */
         //
         //

         // Create result object
         squirrel_kclhand_msgs::TrackNewSetpointsActionFeedback::_feedback_type feedback_;
         squirrel_kclhand_msgs::TrackNewSetpointsActionResult::_result_type result_;

         // Update all "tracked" setpoints with the values stored in the "next" setpoints
         for (std::vector<squirrel_kclhand_msgs::Joint>::iterator it = this->joint_vector.begin(); it != this->joint_vector.end(); ++it)
         {
           it->joint_angle_setpoint_tracked = it->joint_angle_setpoint_next;
         }

         result_.status = "Setpoints updated.";
         as_->setSucceeded(result_);

         //
         //
         /* protected region user implementation of action callback for track_new_setpoints end */
    }
    void callback_set_max_joint_velocity_(const squirrel_kclhand_msgs::SetMaxJointVelocityGoalConstPtr &goal, actionlib::SimpleActionServer<squirrel_kclhand_msgs::SetMaxJointVelocityAction> *as_)
    {
        /* protected region user implementation of action callback for set_max_joint_velocity on begin */
        /* protected region user implementation of action callback for set_max_joint_velocity end */
    }
    /* protected region user additional functions on begin */
       ///
       //

       void simulated()
       {
         // simulate hand motion
         double trackingError;
         double simJointPosGain;
         double simSamplingTime;
         double simJointInertia;
         double simJointDamping;

         ros::param::get("~Simulated_Joint_Pos_Gain", simJointPosGain);
         ros::param::get("~Simulated_Joint_Inertia", simJointInertia);
         ros::param::get("~Simulation_Sampling_Time", simSamplingTime);
         ros::param::get("~Simulated_Joint_Damping", simJointDamping);

         for (std::vector<squirrel_kclhand_msgs::Joint>::iterator it = this->joint_vector.begin(); it != this->joint_vector.end(); ++it)
         {
           trackingError = it->joint_angle_setpoint_tracked - it->joint_angle;
           it->joint_effort = trackingError * simJointPosGain; // - simJointDamping * it->joint_velocity
           it->joint_velocity += simSamplingTime * (it->joint_effort / simJointInertia);

           it->joint_angle += it->joint_velocity;//joint_velocity;
         }
       }

       void ideal()
       {
         for (std::vector<squirrel_kclhand_msgs::Joint>::iterator it = this->joint_vector.begin(); it != this->joint_vector.end(); ++it)
         {
           // Assume ideal joint tracking
           it->joint_angle = it->joint_angle_setpoint_tracked;
         }
       }

       ~kclhand_impl()
       {
         commChannel->disconnectFromHand();
       }

    /* protected region user additional functions on begin */
    /* protected region user additional functions end */
};
